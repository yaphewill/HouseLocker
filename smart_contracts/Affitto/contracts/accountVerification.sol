// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.2 <0.9.0;
import "./ECDSA.sol";
import "./Secp256k1.sol";
import "./EllipticCurve.sol";
import "./EllipticCurveFastMult.sol";
import "./zkp.sol";

contract accountVerification{
   
    // Takes in a private key and returns the corresponding public key
    // Everyone knows the input of a function. DO NOT USE IT IN A PUBLIC BLOCKCHAIN!
    function getPub_kFromPriv_k(bytes32 pr_k) public pure returns(bytes32, bytes32){
        (uint256 pub_key_x, uint256 pub_key_y) = EllipticCurve.ecMul(uint256(pr_k), Secp256k1.getGX(), Secp256k1.getGY(), Secp256k1.getAA(), Secp256k1.getPP());
        return (bytes32(pub_key_x), bytes32(pub_key_y));
    }

    // Takes in a public key and returns the corresponding Ethereum address
    function getAddressFromPub_k(bytes32 x, bytes32 y) public pure returns (bytes20){
        string memory x_s = string(abi.encodePacked(x));
        string memory y_s = string(abi.encodePacked(y));
        bytes32 hash = (keccak256(abi.encodePacked(x_s,y_s)));
        uint160 u_hash = uint160(uint256(hash) % 2**160);
        return bytes20(u_hash);
    }

    // Takes in a private key and an Ethereum address and returns a boolean value indicating
    // whether the private key corresponds to the given Ethereum address
    // Everyone knows the input of a function. DO NOT USE IT IN A PUBLIC BLOCKCHAIN!
    function verify(bytes32 pr_k, address a) public pure returns(bool){
        (bytes32 pub_key_x, bytes32 pub_key_y) = getPub_kFromPriv_k(pr_k);
        bytes20 addr = getAddressFromPub_k(pub_key_x, pub_key_y);
        return a==address(addr);
    }

    // Takes in a private key and generates a zero-knowledge proof using the Prover function from the zkp library
    // Everyone knows the input of a function. DO NOT USE IT IN A PUBLIC BLOCKCHAIN!
    function zkp_accountGen(bytes32 pr_k) public view returns (uint256, uint256, uint256, uint256, uint256, uint256){
        return (zkp.Prover(uint256(pr_k)));
    }

    // This version of the zkp_accountVer function takes in a sextuple generated by the Prover function and returns a boolean value indicating
    // whether the proof is valid and correspond to the address of the the person that called
    function zkp_accountVer(uint256 ux, uint256 uy, uint256 c, uint256 z, uint256 hx, uint256 hy) public view returns (bool){      
        return (zkp.Verifier(ux,uy, c, z, hx, hy)) && address(getAddressFromPub_k(bytes32(hx),bytes32(hy)))==msg.sender;
    }

    // Takes in a sextuple generated by the Prover function and an Ethereum address and returns a boolean value indicating whether the proof
    // is valid and corresponds to the given Ethereum address
    function zkp_accountVer(uint256 ux, uint256 uy, uint256 c, uint256 z, uint256 hx, uint256 hy, address addr) public pure returns (bool){        
        return (zkp.Verifier(ux, uy, c, z, hx, hy)) && address(getAddressFromPub_k(bytes32(hx),bytes32(hy)))==addr;
    }


    // Takes in a private key and an Ethereum address and performs a sanity check to see if the computation of the
    // address from the private key is up to date
    // Everyone knows the input of a function. This is only for test. DO NOT USE IT IN A PUBLIC BLOCKCHAIN!
    function sanity_test(bytes32 pr_k, address addr) public pure returns (bool){
        (bytes32 x, bytes32 y) = getPub_kFromPriv_k(pr_k);
        return address(getAddressFromPub_k(x, y)) == addr;
    }

    // Takes in a private key and and performs a sanity check to see if the computation of the address
    // from the private key is up to date, the address is taken directly from the sender
    // Everyone knows the input of a function. This is only for test. DO NOT USE IT IN A PUBLIC BLOCKCHAIN!
    function sanity_test(bytes32 pr_k) public view  returns (bool){
        (bytes32 x, bytes32 y) = getPub_kFromPriv_k(pr_k);
        return address(getAddressFromPub_k(x, y)) == msg.sender;
    }
   
    // Takes in a private key and an Ethereum address and return whether the private key and the address are associated
    // using the zkp, the function returns always true if you put your true data up to the correctness of zkp.
    // Everyone knows the input of a function. This is only for test. DO NOT USE IT IN A PUBLIC BLOCKCHAIN!
    function test(bytes32 pr_k, address addr) public view returns (bool){
        (uint256 ux, uint256 uy, uint256 c, uint256 z, uint256 hx, uint256 hy) = zkp_accountGen(pr_k);
        return zkp_accountVer(ux,  uy,  c,  z,  hx,  hy, addr);
    }
}